package main

import (
	"context"
	"encoding/csv"
	"fmt"
	"log"
	"os"
	"sort"
	"strings"
	"text/tabwriter"
	"time"

	"github.com/abruno06/myvault/config"
	"github.com/abruno06/myvault/crypto"
	"github.com/abruno06/myvault/interactif"
	"github.com/abruno06/myvault/secret"
	"github.com/abruno06/myvault/securestore"
	"github.com/abruno06/myvault/smartcard"
	"github.com/go-piv/piv-go/piv"
	"github.com/hashicorp/vault-client-go"
	"github.com/hashicorp/vault-client-go/schema"
)

var VAULTURL = "https://172.0.0.1:8200"
var APPNAME = "myapp"

const AskSecretID = "Enter Secret ID: "

// reset to this
type Secret struct {
	Username     string
	Credential   string
	URL          string //optional
	Comment      string
	LastUpdate   time.Time
	LastUpdateBy string
}

var SecretFieldNames = secret.SecretFieldNames
var SecretHumanFieldNames = secret.SecretHumanFieldNames

//Vault piece

// convert the map[string]interface {}  to Secret
// return the secret and true if the conversion is successful otherwise return empty secret and false
func convertToSecret(object map[string]interface{}) (Secret, bool) {
	rValue := Secret{}
	var ok bool
	rValue.Username, ok = object["Username"].(string)
	if !ok {
		return rValue, ok
	}
	rValue.Credential, ok = object["Credential"].(string)
	if !ok {
		return rValue, ok
	}
	rValue.Comment, ok = object["Comment"].(string)
	if !ok {
		return rValue, ok
	}
	rValue.URL, ok = object["URL"].(string)
	if !ok {
		return rValue, ok
	}
	if object["LastUpdate"] == nil {
		rValue.LastUpdate, _ = time.Parse("2006-01-02 15:04:05", "0001-01-01 00:00:00 ")
	} else {
		rValue.LastUpdate, _ = time.Parse("2006-01-02T15:04:05.999999-07:00", object["LastUpdate"].(string))
	}
	rValue.LastUpdateBy, _ = object["LastUpdateBy"].(string)
	return rValue, ok
}

// this function will ask the user to enter the secret id and it will search it in vault and allow update it if the secret did not expire
func updateSecretInteractive(ctx context.Context, client *vault.Client, mountpath string) error {
	//read the secret id from the user
	fmt.Print(AskSecretID)
	var secretID string
	fmt.Scanln(&secretID)
	//fmt.Printf("Secret ID: %s\n", secretID)
	//read the secret for the readAPPNAME()
	s, err := client.Secrets.KvV2Read(ctx, config.ReadAPPNAME(), vault.WithMountPath(mountpath))
	if err != nil {
		log.Fatal(err)
	}
	//read the secret from the user
	fieldNames := SecretHumanFieldNames
	fieldValues := make(map[string]string)
	for _, fieldName := range fieldNames {
		if fieldValue, ok := s.Data.Data[secretID].(map[string]interface{})[fieldName]; ok {
			fieldValues[fieldName] = fieldValue.(string)
		} else {
			fieldValues[fieldName] = "" // Default to empty string if the field is not present
		}
	}

	s.Data.Data[secretID] = askSecretParameter(fieldValues)
	_, err = client.Secrets.KvV2Write(ctx, config.ReadAPPNAME(), schema.KvV2WriteRequest{
		Data: s.Data.Data,
	},
		vault.WithMountPath(mountpath))
	if err != nil {
		log.Fatal(err)
	}
	return err
}

// function will ask for secret parameter and return as  Secret struct
func askSecretParameter(Previous ...map[string]string) Secret {
	//read the secret from the user
	fieldValues := make(map[string]string)
	//Check if Previous is passed
	if len(Previous) > 0 {
		for key, field := range Previous[0] {
			var value string
			if key == "Credential" {
				rndPwd := crypto.RandomPassword(12, true, true, true, true, "!@#$%^&*()_+-")
				fmt.Printf("Enter %s: (%s) (* if you want random) ", key, field)
				fmt.Scanln(&value)
				if value == "*" {
					value = rndPwd
				} else if value == "" {
					value = field
				}
				fieldValues[key] = value
			} else {
				fmt.Printf("Enter %s: (%s) ", key, field)

				fmt.Scanln(&value)
				if value == "" {
					value = field
				}
			}
			fieldValues[key] = value
		}
	} else {
		for _, field := range SecretHumanFieldNames {
			var value string
			if field == "Credential" {
				rndPwd := crypto.RandomPassword(10, true, true, true, true, "!@#$%^&*()_+-")
				fmt.Printf("Enter %s (or hit enter to have autogenerated) ", field)
				fmt.Scanln(&value)
				if value == "" {
					value = rndPwd
				}
			} else {
				fmt.Printf("Enter %s: ", field)
				fmt.Scanln(&value)
			}
			fieldValues[field] = value
		}
	}
	rValue := Secret{
		Username:     fieldValues["Username"],
		Credential:   fieldValues["Credential"],
		URL:          fieldValues["URL"],
		Comment:      fieldValues["Comment"],
		LastUpdate:   time.Now(),
		LastUpdateBy: config.User,
	}
	return rValue
}

// this function take vault client will ask the user to enter a secret id and it will be searched in vault and returned it if the secret did not expire then return nil
func askSecret(ctx context.Context, client *vault.Client, mountpath string) (Secret, error) {
	//read the secret id from the user
	fmt.Print(AskSecretID)
	var secretID string
	fmt.Scanln(&secretID)
	//fmt.Printf("Secret ID: %s\n", secretID)
	rValue := Secret{}
	//read the secret for the readAPPNAME()
	s, err := client.Secrets.KvV2Read(ctx, config.ReadAPPNAME(), vault.WithMountPath(mountpath))
	if err == nil {
		vValue := s.Data.Data
		if vValue[secretID] != nil {
			var ok bool
			rValue, ok = convertToSecret(vValue[secretID].(map[string]interface{}))
			if !ok {
				log.Printf("Secret ID: %s not valid secret\n", vValue[secretID])
				log.Printf("Secret ID: is type %T \n", vValue[secretID])
				rValue = Secret{}
				err = fmt.Errorf("Secret ID: %s not valid secret", vValue[secretID])
			}
			//fmt.Printf("Secret: %v\n", rValue)
		} else {
			fmt.Printf("Secret ID: %s not found\n", secretID)
			rValue = Secret{}
		}
	}

	//fmt.Printf("Secret: %v\n", s.Data)
	return rValue, err
}
func getSecret(ctx context.Context, client *vault.Client, secretID, mountpath string) (Secret, error) {
	rValue := Secret{}
	//read the secret for the readAPPNAME()
	s, err := client.Secrets.KvV2Read(ctx, config.ReadAPPNAME(), vault.WithMountPath(mountpath))
	if err == nil {
		vValue := s.Data.Data
		if vValue[secretID] != nil {
			var ok bool
			rValue, ok = convertToSecret(vValue[secretID].(map[string]interface{}))
			if !ok {
				log.Printf("Secret ID: %s not valid secret\n", vValue[secretID])
				log.Printf("Secret ID: is type %T \n", vValue[secretID])
				rValue = Secret{}
				err = fmt.Errorf("Secret ID: %s not valid secret", vValue[secretID])
			}
			//fmt.Printf("Secret: %v\n", rValue)
		} else {
			fmt.Printf("Secret ID: %s not found\n", secretID)
			rValue = Secret{}
		}
	}

	//fmt.Printf("Secret: %v\n", s.Data)
	return rValue, err
}

// this function list all secrets in vault for the given mountpath and readAPPNAME() and display them in tabuuar format
func listSecrets(ctx context.Context, client *vault.Client, mountpath string) error {
	//read the secret for the readAPPNAME()
	list, err := client.Secrets.KvV2Read(ctx, config.ReadAPPNAME(), vault.WithMountPath(mountpath))
	if err != nil {
		//log.Fatal(err)
		log.Println("No secrets found")
	}
	//fmt.Printf("List: %v\n", list)
	//display all secrets found in tabular format
	// Create a tabwriter
	w := tabwriter.NewWriter(os.Stdout, 0, 0, 3, ' ', 0)

	columns := SecretFieldNames
	//create the format
	format := "%s\t%s\t%s\t%s\t%s\t%s\t%s\n"
	//print the header
	fmt.Fprintf(w, format, "ID", columns[0], columns[1], columns[2], columns[3], columns[4], columns[5])
	//print the data
	//make data order in alphabetical order
	Data := list.Data.Data
	var keys []string
	for key := range Data {
		keys = append(keys, key)
	}
	// Sort the keys case-insensitively
	sort.Slice(keys, func(i, j int) bool {
		return strings.ToLower(keys[i]) < strings.ToLower(keys[j])
	})

	for _, k := range keys {
		var ok bool
		v := Data[k]
		secret, ok := convertToSecret(v.(map[string]interface{}))
		if ok {
			fmt.Fprintf(w, format, k, secret.Username, secret.Credential, secret.URL, secret.LastUpdate.UTC().Format("2006-01-02 15:04:05"), secret.LastUpdateBy, secret.Comment)

		}
	}
	w.Flush()
	return err

}

func addSecret(ctx context.Context, client *vault.Client, mountpath, secretID string, secret Secret) error {
	//read the secret id from the user

	//read the secret for the readAPPNAME()
	s, err := client.Secrets.KvV2Read(ctx, config.ReadAPPNAME(), vault.WithMountPath(mountpath))
	if err != nil {
		log.Fatal(err)
	}
	//ask the Secret detail
	s.Data.Data[secretID] = secret

	_, err = client.Secrets.KvV2Write(ctx, config.ReadAPPNAME(), schema.KvV2WriteRequest{
		Data: s.Data.Data,
	},
		vault.WithMountPath(mountpath))
	if err != nil {
		log.Fatal(err)
	}
	return err
}

// this function will ask the user an ID and a secret and it will be stored in vault
func addSecretInteractive(ctx context.Context, client *vault.Client, mountpath string) error {
	//read the secret id from the user
	var secretID string
	for {
		fmt.Print(AskSecretID)
		fmt.Scanln(&secretID)
		//check if secretID already exist
		if checkSecretID(ctx, client, mountpath, secretID) {
			fmt.Printf("Secret ID: %s already exist\n", secretID)
		} else {
			break
		}
	}
	//fmt.Printf("Secret ID: %s\n", secretID)
	//read the secret for the readAPPNAME()
	s, err := client.Secrets.KvV2Read(ctx, config.ReadAPPNAME(), vault.WithMountPath(mountpath))
	if err != nil {
		log.Fatal(err)
	}
	//ask the Secret detail
	s.Data.Data[secretID] = askSecretParameter()

	_, err = client.Secrets.KvV2Write(ctx, config.ReadAPPNAME(), schema.KvV2WriteRequest{
		Data: s.Data.Data,
	},
		vault.WithMountPath(mountpath))
	if err != nil {
		log.Fatal(err)
	}
	return err
}

// this function will ask the user an ID and it will delete it from vault
func deleteSecretInteractive(ctx context.Context, client *vault.Client, mountpath string) error {
	//read the secret id from the user
	fmt.Print(AskSecretID)
	var secretID string
	fmt.Scanln(&secretID)
	//fmt.Printf("Secret ID: %s\n", secretID)
	//read the secret for the readAPPNAME()
	s, err := client.Secrets.KvV2Read(ctx, config.ReadAPPNAME(), vault.WithMountPath(mountpath))
	if err != nil {
		log.Fatal(err)
	}
	//fmt.Printf("Secret: %v\n", s.Data)
	//delete the secret
	delete(s.Data.Data, secretID)
	_, err = client.Secrets.KvV2Write(ctx, config.ReadAPPNAME(), schema.KvV2WriteRequest{
		Data: s.Data.Data,
	},
		vault.WithMountPath(mountpath))
	if err != nil {
		log.Fatal(err)
	}
	return err
}

// create a menu based cli with option to select the action
func menu(ctx context.Context, client *vault.Client, mountpath string) {
	for {
		fmt.Println("Select Action")
		fmt.Println("1. List Secrets")
		fmt.Println("2. Add Secret")
		fmt.Println("3. Delete Secret")
		fmt.Println("4. Update Secret")
		fmt.Println("5. Get Secret")
		fmt.Println("6. Read CSV File")
		fmt.Println("7. Exit")
		fmt.Println("8. Random Password")
		fmt.Print("Enter Action Number: ")
		var actionNumber int
		fmt.Scanln(&actionNumber)
		switch actionNumber {
		case 1:
			fmt.Println("List Secrets")
			listSecrets(ctx, client, mountpath)
		case 2:
			fmt.Println("Add Secret")
			addSecretInteractive(ctx, client, mountpath)
			listSecrets(ctx, client, mountpath)
		case 3:
			listSecrets(ctx, client, mountpath)
			fmt.Println("Delete Secret")
			deleteSecretInteractive(ctx, client, mountpath)
			listSecrets(ctx, client, mountpath)
		case 4:
			fmt.Println("Update Secret")
			updateSecretInteractive(ctx, client, mountpath)
			listSecrets(ctx, client, mountpath)
		case 5:
			fmt.Println("Get Secret")
			askSecret(ctx, client, mountpath)
		case 6:
			fmt.Println("Read CSV File")
			fmt.Print("Enter CSV Filename: ")
			var filename string
			fmt.Scanln(&filename)
			readCSV(ctx, client, mountpath, filename)
			listSecrets(ctx, client, mountpath)
		case 7:
			fmt.Println("Exit")
			return
		case 8:
			//return random password
			fmt.Println("Random Password")
			fmt.Print("Enter Password Length: ")
			var length int
			fmt.Scanln(&length)
			//if empty use default
			if length == 0 {
				length = 12
				fmt.Printf("Password Length: %d\n", length)
			}
			fmt.Print("Enter Password Complexity (l=lowercase, u=uppercase, d=digit, s=special): ")
			var complexity string
			fmt.Scanln(&complexity)
			//if empty use default
			if complexity == "" {
				complexity = "luds"
				fmt.Printf("Password Complexity: %s\n", complexity)
			}
			fmt.Print("Enter Special Characters: ")
			var special string
			fmt.Scanln(&special)
			//if empty use default
			if special == "" {
				special = "!@#$%^&*()_+-"
				fmt.Printf("Special Characters: %s\n", special)
			}
			fmt.Printf("Password: %s\n", crypto.RandomPassword(length, strings.Contains(complexity, "l"), strings.Contains(complexity, "u"), strings.Contains(complexity, "d"), strings.Contains(complexity, "s"), special))

		default:
			fmt.Println("Exit")
			return
		}

	}
}

//check if yubikey is plugged in and return bool

func checkYubikey() bool {
	yubikey, err := piv.Cards()
	if err != nil {
		log.Fatal(err)
	}
	if len(yubikey) == 0 {
		return false
	}
	return true
}

// CSV record to Secret
func csvToSecret(record []string) Secret {
	rValue := Secret{
		Username:     record[1],
		Credential:   record[2],
		URL:          record[3],
		Comment:      record[4],
		LastUpdate:   time.Now(),
		LastUpdateBy: config.User,
	}
	return rValue
}

// check if SecretId already exist in vault
func checkSecretID(ctx context.Context, client *vault.Client, mountpath, secretID string) bool {
	//read the secret for the readAPPNAME()
	s, err := client.Secrets.KvV2Read(ctx, config.ReadAPPNAME(), vault.WithMountPath(mountpath))
	if err != nil {
		log.Fatal(err)
	}
	//delete the secret
	if s.Data.Data[secretID] != nil {
		return true
	}
	return false
}

// readCSV file and insert the data in vault as Secret
func readCSV(ctx context.Context, client *vault.Client, mountpath, filename string) {
	//read the csv file
	// Open the file
	csvfile, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	// Parse the file
	r := csv.NewReader(csvfile)
	// Iterate through the records and insert them in vault. stop when EOF
	for {
		// Read each record from csv
		// CSV Format is
		// ID,Username,Credential,URL,Comment
		// LastUpdate,LastUpdateBy are automatically added

		record, err := r.Read()
		if err != nil {
			fmt.Println(err)
			break

		}
		fmt.Printf("Record: %v\n", record)
		//ask the Secret detail
		addSecret(ctx, client, mountpath, record[0], csvToSecret(record))

	}

}

// main function
func main() {
	//read the configuration file
	//fmt.Printf("config:%s")
	//prepare the context
	ctx := context.Background()
	//print the default the app is running
	fmt.Printf("myvault is running with APPNAME: %s and VAULTURL: %s\n", config.ReadAPPNAME(), config.ReadVaultURL())

	var c *vault.Client
	var e error
	// check yubikey is plugged in
	if checkYubikey() {

		yk := smartcard.OpenYubikey(interactif.SelectSmartcard())
		defer yk.Close()
		cert := smartcard.ReadYubikeyCertificate(yk, smartcard.SelectSlot())
		//fmt.Printf("Certificate: %v\n", cert)
		//fmt.Printf("Certificate: %v\n", cert.PublicKey)
		fmt.Printf("Certificate: %v\n", cert.PublicKeyAlgorithm)
		c, e = securestore.ConnectVaulwithYubikey(ctx, yk)

	} else {
		fmt.Println("No Yubikey found. Falling back to username and password")
		//ask username and password
		username, password := interactif.ReadUsernamePassword()
		c, e = securestore.ConnectVaultWithUsernamePassword(ctx, username, password)
	}
	if e != nil {
		log.Fatal(e)
	}
	menu(ctx, c, config.ReadMountPath())

}
