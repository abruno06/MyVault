package main

import (
	"context"
	"encoding/csv"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"github.com/abruno06/myvault/config"
	"github.com/abruno06/myvault/crypto"
	"github.com/abruno06/myvault/interactif"
	"github.com/abruno06/myvault/secret"
	"github.com/abruno06/myvault/securestore"
	"github.com/abruno06/myvault/smartcard"
	"github.com/hashicorp/vault-client-go"
)

var VAULTURL = "https://172.0.0.1:8200"
var APPNAME = "myapp"

const AskSecretID = "Enter Secret ID: "

// reset to this
type Secret struct {
	Username     string
	Credential   string
	URL          string //optional
	Comment      string
	LastUpdate   time.Time
	LastUpdateBy string
}

var SecretFieldNames = secret.SecretFieldNames
var SecretHumanFieldNames = secret.SecretHumanFieldNames

//Vault piece

// convert the map[string]interface {}  to Secret
// return the secret and true if the conversion is successful otherwise return empty secret and false
func convertToSecret(object map[string]interface{}) (Secret, bool) {
	rValue := Secret{}
	var ok bool
	rValue.Username, ok = object["Username"].(string)
	if !ok {
		return rValue, ok
	}
	rValue.Credential, ok = object["Credential"].(string)
	if !ok {
		return rValue, ok
	}
	rValue.Comment, ok = object["Comment"].(string)
	if !ok {
		return rValue, ok
	}
	rValue.URL, ok = object["URL"].(string)
	if !ok {
		return rValue, ok
	}
	if object["LastUpdate"] == nil {
		rValue.LastUpdate, _ = time.Parse("2006-01-02 15:04:05", "0001-01-01 00:00:00 ")
	} else {
		rValue.LastUpdate, _ = time.Parse("2006-01-02T15:04:05.999999-07:00", object["LastUpdate"].(string))
	}
	rValue.LastUpdateBy, _ = object["LastUpdateBy"].(string)
	return rValue, ok
}

// function will ask for secret parameter and return as  Secret struct
func askSecretParameter(Previous ...map[string]string) Secret {
	//read the secret from the user
	fieldValues := make(map[string]string)
	//Check if Previous is passed
	if len(Previous) > 0 {
		for key, field := range Previous[0] {
			var value string
			if key == "Credential" {
				rndPwd := crypto.RandomPassword(12, true, true, true, true, "!@#$%^&*()_+-")
				fmt.Printf("Enter %s: (%s) (* if you want random) ", key, field)
				fmt.Scanln(&value)
				if value == "*" {
					value = rndPwd
				} else if value == "" {
					value = field
				}
				fieldValues[key] = value
			} else {
				fmt.Printf("Enter %s: (%s) ", key, field)

				fmt.Scanln(&value)
				if value == "" {
					value = field
				}
			}
			fieldValues[key] = value
		}
	} else {
		for _, field := range SecretHumanFieldNames {
			var value string
			if field == "Credential" {
				rndPwd := crypto.RandomPassword(10, true, true, true, true, "!@#$%^&*()_+-")
				fmt.Printf("Enter %s (or hit enter to have autogenerated) ", field)
				fmt.Scanln(&value)
				if value == "" {
					value = rndPwd
				}
			} else {
				fmt.Printf("Enter %s: ", field)
				fmt.Scanln(&value)
			}
			fieldValues[field] = value
		}
	}
	rValue := Secret{
		Username:     fieldValues["Username"],
		Credential:   fieldValues["Credential"],
		URL:          fieldValues["URL"],
		Comment:      fieldValues["Comment"],
		LastUpdate:   time.Now(),
		LastUpdateBy: config.User,
	}
	return rValue
}

// this function take vault client will ask the user to enter a secret id and it will be searched in vault and returned it if the secret did not expire then return nil
func askSecret(ctx context.Context, client *vault.Client, mountpath string) (Secret, error) {
	//read the secret id from the user
	fmt.Print(AskSecretID)
	var secretID string
	fmt.Scanln(&secretID)
	//fmt.Printf("Secret ID: %s\n", secretID)
	rValue := Secret{}
	//read the secret for the readAPPNAME()
	s, err := client.Secrets.KvV2Read(ctx, config.ReadAPPNAME(), vault.WithMountPath(mountpath))
	if err == nil {
		vValue := s.Data.Data
		if vValue[secretID] != nil {
			var ok bool
			rValue, ok = convertToSecret(vValue[secretID].(map[string]interface{}))
			if !ok {
				log.Printf("Secret ID: %s not valid secret\n", vValue[secretID])
				log.Printf("Secret ID: is type %T \n", vValue[secretID])
				rValue = Secret{}
				err = fmt.Errorf("Secret ID: %s not valid secret", vValue[secretID])
			}
			//fmt.Printf("Secret: %v\n", rValue)
		} else {
			fmt.Printf("Secret ID: %s not found\n", secretID)
			rValue = Secret{}
		}
	}

	//fmt.Printf("Secret: %v\n", s.Data)
	return rValue, err
}

// this function will ask the user an ID and it will delete it from vault

// create a menu based cli with option to select the action
func menu(ctx context.Context, secstore securestore.SecretStore) {
	client := secstore.Client
	mountpath := secstore.Mountpath
	//display the current token
	for {
		fmt.Println("Select Action")
		fmt.Println("1. List Secrets")
		fmt.Println("2. Add Secret")
		fmt.Println("3. Delete Secret")
		fmt.Println("4. Update Secret")
		fmt.Println("5. Get Secret")
		fmt.Println("6. Read CSV File")
		fmt.Println("7. Random Password")
		fmt.Println("8. Generate bootstrap token")
		fmt.Println("9. Exit")
		fmt.Print("Enter Action Number: ")
		var actionNumber int
		fmt.Scanln(&actionNumber)
		switch actionNumber {
		case 1:
			fmt.Println("List Secrets")
			securestore.ListSecrets(ctx, secstore)
		case 2:
			fmt.Println("Add Secret")
			interactif.AddSecretInteractive(ctx, secstore)
			securestore.ListSecrets(ctx, secstore)
		case 3:
			securestore.ListSecrets(ctx, secstore)
			fmt.Println("Delete Secret")
			interactif.DeleteSecretInteractive(ctx, secstore)
			securestore.ListSecrets(ctx, secstore)
		case 4:
			fmt.Println("Update Secret")
			interactif.UpdateSecretInteractive(ctx, secstore)
			securestore.ListSecrets(ctx, secstore)
		case 5:
			fmt.Println("Get Secret")
			askSecret(ctx, client, mountpath)
		case 6:
			fmt.Println("Read CSV File")
			fmt.Print("Enter CSV Filename: ")
			var filename string
			fmt.Scanln(&filename)
			readCSV(ctx, secstore, filename)
			securestore.ListSecrets(ctx, secstore)
		case 7:
			//return random password
			fmt.Println("Random Password")
			fmt.Print("Enter Password Length: ")
			var length int
			fmt.Scanln(&length)
			//if empty use default
			if length == 0 {
				length = 12
				fmt.Printf("Password Length: %d\n", length)
			}
			fmt.Print("Enter Password Complexity (l=lowercase, u=uppercase, d=digit, s=special): ")
			var complexity string
			fmt.Scanln(&complexity)
			//if empty use default
			if complexity == "" {
				complexity = "luds"
				fmt.Printf("Password Complexity: %s\n", complexity)
			}
			fmt.Print("Enter Special Characters: ")
			var special string
			fmt.Scanln(&special)
			//if empty use default
			if special == "" {
				special = "!@#$%^&*()_+-"
				fmt.Printf("Special Characters: %s\n", special)
			}
			fmt.Printf("Password: %s\n", crypto.RandomPassword(length, strings.Contains(complexity, "l"), strings.Contains(complexity, "u"), strings.Contains(complexity, "d"), strings.Contains(complexity, "s"), special))
		case 8:
			fmt.Println("Generate bootstrap token")
			fmt.Print("Enter Token TTL (in minutes): ")
			var ttl int
			fmt.Scanln(&ttl)
			//if empty use default
			if ttl == 0 {
				ttl = 24
				fmt.Printf("Token TTL: %d\n", ttl)
			}
			//select the SecretId
			fmt.Print("Enter Secret ID: ")
			var secretID string
			fmt.Scanln(&secretID)
			wToken, err := securestore.WrapSecret(ctx, secstore, secretID, time.Duration(ttl)*time.Minute)
			if err != nil {
				log.Fatal(err)
			}
			fmt.Printf("Bootstrap Token: %s\n", wToken)
		case 9:
			fmt.Println("Exit")
			return
		default:
			fmt.Println("Exit")
			return
		}

	}
}

//check if yubikey is plugged in and return bool

// CSV record to Secret
func csvToSecret(record []string) secret.Secret {
	rValue := secret.Secret{
		Username:     record[1],
		Credential:   record[2],
		URL:          record[3],
		Comment:      record[4],
		LastUpdate:   time.Now(),
		LastUpdateBy: config.User,
	}
	return rValue
}

// readCSV file and insert the data in vault as Secret
func readCSV(ctx context.Context, secstore securestore.SecretStore, filename string) {
	//read the csv file
	// Open the file
	csvfile, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	// Parse the file
	r := csv.NewReader(csvfile)
	// Iterate through the records and insert them in vault. stop when EOF
	for {
		// Read each record from csv
		// CSV Format is
		// ID,Username,Credential,URL,Comment
		// LastUpdate,LastUpdateBy are automatically added

		record, err := r.Read()
		if err != nil {
			fmt.Println(err)
			break

		}
		fmt.Printf("Record: %v\n", record)
		//ask the Secret detail
		securestore.AddSecret(ctx, secstore, csvToSecret(record), record[0])

	}

}

// main function
func main() {
	//read the configuration file
	//fmt.Printf("config:%s")
	//prepare the context
	ctx := context.Background()
	//print the default the app is running
	fmt.Printf("myvault is running with APPNAME: %s and VAULTURL: %s\n", config.ReadAPPNAME(), config.ReadVaultURL())
	var secstore securestore.SecretStore
	var e error
	// check yubikey is plugged in
	if smartcard.CheckYubikey() {

		yk := smartcard.OpenYubikey(interactif.SelectSmartcard())
		defer yk.Close()
		cert := smartcard.ReadYubikeyCertificate(yk, smartcard.SelectSlot())
		//fmt.Printf("Certificate: %v\n", cert)
		//fmt.Printf("Certificate: %v\n", cert.PublicKey)
		fmt.Printf("Certificate: %v\n", cert.PublicKeyAlgorithm)
		//ask user pin
		pin := interactif.ReadPin()
		secstore, e = securestore.ConnectVaulwithYubikey(ctx, yk, pin)
		if e != nil {
			fmt.Println("Bad Pin. Falling back to username and password")
			username, password := interactif.ReadUsernamePassword()
			secstore, e = securestore.ConnectVaultWithUsernamePassword(ctx, username, password)
		}
	} else {
		fmt.Println("No Yubikey found. Falling back to username and password")
		//ask username and password
		username, password := interactif.ReadUsernamePassword()
		secstore, e = securestore.ConnectVaultWithUsernamePassword(ctx, username, password)

	}
	if e != nil {
		log.Fatal(e)
	}
	menu(ctx, secstore)

}
