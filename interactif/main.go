package interactif

import (
	"bufio"
	"context"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/abruno06/myvault/config"
	"github.com/abruno06/myvault/crypto"
	"github.com/abruno06/myvault/secret"
	"github.com/abruno06/myvault/securestore"
)

// this package will contain all the functions to interact with the user
// it will be used by the main.go file
var SecretFieldNames = []string{"Username", "Credential", "URL", "LastUpdate", "LastUpdateBy", "Comment"}
var SecretHumanFieldNames = []string{"Username", "Credential", "URL", "Comment"}

const AskSecretID = "Enter Secret ID: "

// select  smartcard type
func SelectSmartcard() string {
	var smartcard string
	fmt.Println("Select Smartcard (Default is Yubikey)")
	fmt.Println("1. Yubikey")
	fmt.Println("2. Nitrokey")
	fmt.Println("3. Other")
	fmt.Print("Enter Smartcard Number: ")
	var smartcardNumber int
	fmt.Scanln(&smartcardNumber)
	switch smartcardNumber {
	case 1:
		smartcard = "yubikey"
	case 2:
		smartcard = "nitrokey"
	case 3:
		smartcard = "other"
	default:
		smartcard = "yubikey"
	}
	return smartcard
}

// this function will ask the user to enter the value of the field and return the value as map[string]string
func AskUserwithPrevious(Previous map[string]string) map[string]string {
	scanner := bufio.NewScanner(os.Stdin)
	fieldValues := make(map[string]string)
	for key, field := range Previous {
		var value string
		if key == "Credential" {
			rndPwd := crypto.RandomPassword(12, true, true, true, true, "!@#$%^&*()_+-")
			fmt.Printf("Enter %s: (%s) (* if you want random) ", key, field)
			scanner.Scan()
			value = scanner.Text()
			if value == "*" {
				value = rndPwd
			} else if value == "" {
				value = field
			}
			fieldValues[key] = value
		} else {
			fmt.Printf("Enter %s: (%s) ", key, field)
			scanner.Scan()
			value = scanner.Text()
			if value == "" {
				value = field
			}
		}
		fieldValues[key] = value
	}
	//fix the automatic fields
	fieldValues["LastUpdate"] = time.Now().Format("2006-01-02T15:04:05.999999-07:00")
	fieldValues["LastUpdateBy"] = config.User
	//fmt.Printf("fieldValues: %v\n", fieldValues)
	return fieldValues

}

// this function will ask the user to enter the value of the field and return the value as map[string]string
func AskUser() map[string]string {
	scanner := bufio.NewScanner(os.Stdin)
	fieldValues := make(map[string]string)
	for _, field := range SecretHumanFieldNames {
		var value string
		if field == "Credential" {
			rndPwd := crypto.RandomPassword(10, true, true, true, true, "!@#$%^&*()_+-")
			fmt.Printf("Enter %s (or hit enter to have autogenerated) ", field)
			scanner.Scan()
			value = scanner.Text()
			if value == "" {
				value = rndPwd
			}
		} else {
			fmt.Printf("Enter %s: ", field)
			scanner.Scan()
			value = scanner.Text()
		}
		fieldValues[field] = value
	}
	//fix the automatic fields
	fieldValues["LastUpdate"] = time.Now().Format("2006-01-02T15:04:05.999999-07:00")
	fieldValues["LastUpdateBy"] = config.User
	return fieldValues
}

// read user input for smartcard pin
func ReadPin() string {
	fmt.Print("Enter PIN: ")
	var pin string
	fmt.Scanln(&pin)
	//	fmt.Printf("PIN: %s\n", pin)
	return pin
}

// ask for username and password and return them
func ReadUsernamePassword() (string, string) {
	fmt.Print("Enter Username: ")
	var username string
	fmt.Scanln(&username)
	fmt.Print("Enter Password: ")
	var password string
	fmt.Scanln(&password)
	return username, password
}

// convertor
func convertMap(oMap map[string]string) map[string]interface{} {
	rMap := make(map[string]interface{})

	for key, value := range oMap {
		rMap[key] = value
	}

	return rMap
}

// this function will ask the user an ID and a secret and it will be stored in vault
func AddSecretInteractive(ctx context.Context, secstore securestore.SecretStore) error {
	//read the secret id from the user
	var secretID string
	for {
		fmt.Print(AskSecretID)
		fmt.Scanln(&secretID)
		//check if secretID already exist
		if securestore.CheckSecretID(ctx, secstore, secretID) {
			fmt.Printf("Secret ID: %s already exist\n", secretID)
		} else {
			break
		}
	}
	//ask the Secret detail
	fieldValues := AskUser()
	//convet to secret
	newSecret, _ := secret.ConvertToSecret(convertMap(fieldValues))
	err := securestore.AddSecret(ctx, secstore, newSecret, secretID)
	return err

}

// this function will ask the user to enter the secret id and it will search it in vault and allow update it if the secret did not expire
func UpdateSecretInteractive(ctx context.Context, secstore securestore.SecretStore) error {

	//read the secret id from the user
	secretID := AskSecret()

	//	currentSecret := secret.ConvertFromSecret(securestore.GetSecret(ctx, secstore, secretID))

	sec, err := securestore.GetSecret(ctx, secstore, secretID)
	if err != nil {
		log.Fatal(err)
	}
	//convert secret to map[string]interface{}
	currentSecret := secret.ConvertFromSecret(sec)

	//read the secret from the user
	fieldNames := SecretHumanFieldNames
	fieldValues := make(map[string]string)
	for _, fieldName := range fieldNames {
		if fieldValue, ok := currentSecret[fieldName]; ok {
			fieldValues[fieldName] = fieldValue.(string)
		} else {
			fieldValues[fieldName] = "" // Default to empty string if the field is not present
		}
	}

	newValue := AskUserwithPrevious(fieldValues)
	//fmt.Printf("newValue: %v\n", newValue)
	//convert to secret
	newSecret, _ := secret.ConvertToSecret(convertMap(newValue))
	//fmt.Printf("newSecret: %v\n", newSecret)
	securestore.AddSecret(ctx, secstore, newSecret, secretID)
	if err != nil {
		log.Fatal(err)
	}
	return err
}

// this function will ask the user an ID and it will delete it from vault
func DeleteSecretInteractive(ctx context.Context, secstore securestore.SecretStore) error {
	//delete the secret
	err := securestore.DeleteSecret(ctx, secstore, AskSecret())

	return err
}

// Ask the user to enter a secret Id
func AskSecret() string {
	var secretID string
	fmt.Print(AskSecretID)
	fmt.Scanln(&secretID)
	return secretID
}
